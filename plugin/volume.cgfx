float3 view_dir_world : ViewDirection < string Space = "World"; >;
float4x4 world_mat : World < string UIWidget = "None"; >;
float4x4 world_view_proj_mat : WorldViewProjection < string UIWidget = "None"; >;

//float3 volume_size_units < string UIWidget = "None"; >;   // Size of original volume in index space.
float3 volume_size_model < string UIWidget = "None"; >;   // Size of volume in model space.
float3 volume_origin_model < string UIWidget = "None"; >; // Origin of volume in model space.
texture volume_texture < string UIWidget = "None"; string TextureType = "3D"; >;
sampler3D volume_sampler = sampler_state {
    Texture = <volume_texture>;
};

uniform float3 scattering = float3(1.5, 1.5, 1.5) * 3;
uniform float3 absorption = float3(0.1, 0.1, 0.1) * 3;
uniform float shadow_gain = 0; //0.2;
uniform float shadow_step_world = 4;

uniform float3 light_dir_world = float3(0.3, 0.3, 0);
uniform float3 light_color = float3(0.7, 0.7, 0.7);


// ======== VERTEX SHADER ========

struct VERT_INPUT
{
    float3 pos_unit_cube : Position;
};

struct VERT_OUTPUT
{
    float4 pos_clip : Position;
    float3 tex_coord : Texcoord0;
    float3 pos_model : Texcoord1;
    float3 slice_vector_world : Texcoord2;
};

VERT_OUTPUT VolumeVertexShader(VERT_INPUT input)
{
    VERT_OUTPUT output;

    int3 volume_size_voxels = tex3Dsize(volume_sampler, 0);

    // Slice along axis of steepest angle w.r.t. camera.
    float3 local_x_world = normalize(world_mat._m00_m10_m20);
    float3 local_y_world = normalize(world_mat._m01_m11_m21);
    float3 local_z_world = normalize(world_mat._m02_m12_m22);
    float x = dot(local_x_world, view_dir_world),
          y = dot(local_y_world, view_dir_world),
          z = dot(local_z_world, view_dir_world);
    float ax = abs(x), ay = abs(y), az = abs(z);
    float3 pos_unit_cube = input.pos_unit_cube;
    if (ax > ay && ax > az) {
        pos_unit_cube = pos_unit_cube.zxy;
        if (x > 0) pos_unit_cube.x = 1 - pos_unit_cube.x;
        output.slice_vector_world = local_x_world * volume_size_model.x / volume_size_voxels.x;
    } else if (ay > ax && ay > az) {
        pos_unit_cube = pos_unit_cube.yzx;
        if (y > 0) pos_unit_cube.y = 1 - pos_unit_cube.y;
        output.slice_vector_world = local_y_world * volume_size_model.y / volume_size_voxels.y;
    } else {
        pos_unit_cube = pos_unit_cube.xyz;
        if (z > 0) pos_unit_cube.z = 1 - pos_unit_cube.z;
        output.slice_vector_world = local_z_world * volume_size_model.z / volume_size_voxels.z;
    }

    // Pass adjusted unit cube position to fragment shader.
    output.tex_coord = pos_unit_cube;

    // Transform position to model space, and then clip space.
    output.pos_model = volume_size_model * pos_unit_cube + volume_origin_model;
    //float4 pos_world_h = mul(world_mat, float4(pos_model, 1.0f));
    //output.pos_world = pos_world_h.xyz;
    //output.pos_clip = mul(view_proj_mat, pos_world_h);
    output.pos_clip = mul(world_view_proj_mat, float4(output.pos_model, 1));

    return output;
}

// ======== FRAGMENT SHADER ========

/*
float slice_distance_world(axis)
{
    int3 volume_size_voxels = tex2Dsize(volume_texture, 0);
    float3 voxel_size_world = volume_size_world / volume_size_voxels;
    if (axis == 0) {
        return voxel_size_world.x;
    } else if (axis == 1) {
        return voxel_size_world.y;
    } else {
        return voxel_size_world.z;
    }
}
*/

/*
float3 mul_comp(float3 lhs, float3 rhs)
{
    return float3(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z);
}
*/

float3 shadow_raymarch(float3 pos, float3 dir, float3 extinction, float gain)
{
    int max_iter = 8;

    int3 volume_size_voxels = tex3Dsize(volume_sampler, 0);
    float3 step_voxels = shadow_step_world / volume_size_model * volume_size_voxels;
    float step_voxels_max = max(max(step_voxels.x, step_voxels.y), step_voxels.z);
    float lod = log(step_voxels_max) / log(2.f);

    float3 step_texcoords = shadow_step_world / volume_size_model * dir;

    float3 transmittance = float3(1, 1, 1);
    float3 sample_texcoords = (pos - volume_origin_model) / volume_size_model;
    for (int i = 0; i < max_iter; ++i) {
        float density = tex3Dlod(volume_sampler, float4(sample_texcoords, lod)).r;
        transmittance *= exp(extinction * density * shadow_step_world / (1.0 + i*shadow_step_world*gain));
        sample_texcoords += step_texcoords;
    }
    return transmittance;
}

typedef VERT_OUTPUT FRAG_INPUT;

struct FRAG_OUTPUT
{
    float4 color : Color0;
};

FRAG_OUTPUT VolumeFragmentShader(FRAG_INPUT input)
{
    FRAG_OUTPUT output;

    //float density = tex3D(volume_sampler, input.tex_coord).r;
    //output.color = float4(density, density, density, density);

    float3 extinction = -scattering - absorption;
    float3 albedo = light_color * scattering / (scattering + absorption);

    float3 light_dir = normalize(light_dir_world);
    float3 shadow = shadow_raymarch(input.pos_model, -light_dir, extinction, shadow_gain);
    float3 lumi = shadow; //albedo * shadow;

    float density = tex3D(volume_sampler, input.tex_coord).r;
    float slice_thickness = dot(input.slice_vector_world, input.slice_vector_world) / abs(dot(input.slice_vector_world, view_dir_world));
    float3 transmittance = exp(extinction * density * slice_thickness);

    output.color = float4(lumi, 1 - dot(transmittance, float3(1, 1, 1)/3));

    return output;
}

technique Main < int isTransparent = 1; > // TODO: annotations
{
    pass P0 // TODO: annotations
    {
        BlendEnable = true;
        BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha);
        CullFaceEnable = false;
        VertexProgram = compile gp5vp VolumeVertexShader();
        FragmentProgram = compile gp5fp VolumeFragmentShader();
    }
}
