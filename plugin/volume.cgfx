float3 view_dir_world : ViewDirection < string Space = "World"; >;
float4x4 world_mat : World < string UIWidget = "None"; >;
float4x4 world_view_proj_mat : WorldViewProjection < string UIWidget = "None"; >;
float3 volume_size < string UIWidget = "None"; >;
float3 volume_origin < string UIWidget = "None"; >;
texture volume_texture < string UIWidget = "None"; string TextureType = "3D"; >;
sampler3D volume_sampler = sampler_state {
    Texture = <volume_texture>;
};

// ======== VERTEX SHADER ========

struct VERT_INPUT
{
    float3 pos_unit_cube : Position;
};

struct VERT_OUTPUT
{
    float4 pos_clip : Position;
    float3 tex_coord : Texcoord0;
};

VERT_OUTPUT VolumeVertexShader(VERT_INPUT input)
{
    VERT_OUTPUT res;

    // Slice along axis of steepest angle w.r.t. camera.
    float3 local_x_world = normalize(world_mat._m00_m10_m20);
    float3 local_y_world = normalize(world_mat._m01_m11_m21);
    float3 local_z_world = normalize(world_mat._m02_m12_m22);
    float x = dot(local_x_world, view_dir_world),
          y = dot(local_y_world, view_dir_world),
          z = dot(local_z_world, view_dir_world);
    float ax = abs(x), ay = abs(y), az = abs(z);
    float3 pos_unit_cube = input.pos_unit_cube;
    if (ax > ay && ax > az) {
        pos_unit_cube = pos_unit_cube.zxy;
        if (x > 0) pos_unit_cube.x = 1 - pos_unit_cube.x;
    } else if (ay > ax && ay > az) {
        pos_unit_cube = pos_unit_cube.yzx;
        if (y > 0) pos_unit_cube.y = 1 - pos_unit_cube.y;
    } else {
        pos_unit_cube = pos_unit_cube.xyz;
        if (z > 0) pos_unit_cube.z = 1 - pos_unit_cube.z;
    }

    // Pass adjusted unit cube position to fragment shader.
    res.tex_coord = pos_unit_cube;

    // Transform to model space, and then clip space.
    float3 pos_model = volume_size * pos_unit_cube + volume_origin;
    res.pos_clip = mul(world_view_proj_mat, float4(pos_model, 1.0f));

    return res;
}

// ======== FRAGMENT SHADER ========

typedef VERT_OUTPUT FRAG_INPUT;

struct FRAG_OUTPUT
{
    float4 color : Color0;
};

FRAG_OUTPUT VolumeFragmentShader(FRAG_INPUT input)
{
    FRAG_OUTPUT res;

    float density = tex3D(volume_sampler, input.tex_coord).r;
    res.color = float4(density, density, density, density);

    return res;
}

technique Main < int isTransparent = 1; > // TODO: annotations
{
    pass P0 // TODO: annotations
    {
        BlendEnable = true;
        BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha);
        CullFaceEnable = false;
        VertexProgram = compile gp5vp VolumeVertexShader();
        FragmentProgram = compile gp5fp VolumeFragmentShader();
    }
}
