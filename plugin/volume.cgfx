float3 view_dir_world : ViewDirection < string Space = "World"; >;
float4x4 world_mat : World < string UIWidget = "None"; >;
float4x4 world_view_proj_mat : WorldViewProjection < string UIWidget = "None"; >;

float3 volume_size_model < string UIWidget = "None"; >;   // Size of volume in model space.
float3 volume_origin_model < string UIWidget = "None"; >; // Origin of volume in model space.
texture volume_texture < string UIWidget = "None"; string TextureType = "3D"; >;
sampler3D volume_sampler = sampler_state {
    Texture = <volume_texture>;
};

uniform int max_slice_count; // How many slices does the vertex buffer has vertices for.
uniform float slice_size_model;
uniform float min_voxel_value = 0;
uniform float max_voxel_value = 1;

uniform float3 light_dir = float3(0.3, 0.3, 0);
uniform float3 light_color = float3(0.7, 0.7, 0.7);
uniform float3 scattering = float3(1.5, 1.5, 1.5);
uniform float3 absorption = float3(0.1, 0.1, 0.1);
uniform float shadow_gain = 0.2;
uniform int shadow_sample_count = 4;

float SampleVolume(float3 tex_coords, float lod)
{
    return lerp(min_voxel_value, max_voxel_value, tex3Dlod(volume_sampler, float4(tex_coords, lod)).r);
}

// ======== VERTEX SHADER ========

struct VERT_INPUT
{
    float3 dummy_pos : Position;
    int id : VERTEXID;
};

struct VERT_OUTPUT
{
    float4 pos_clip : Position;
    float3 tex_coord : Texcoord0;
    float3 pos_model : Texcoord1;
    float3 slice_vector_world : Texcoord2;
};

VERT_OUTPUT VolumeVertexShader(VERT_INPUT input)
{
    VERT_OUTPUT output;


    int id = input.id;
    float2 pos_slice = float2(id & 1, (id >> 1) & 1);
    int slice_idx = id >> 2;

    // Use dummy attrib to prevent the compiler optimizing it away.
    slice_idx += int(0.000001 * input.dummy_pos.x);

    float3 pos_model;

    // Define a macro for position calculation.
    // Slice axis can be x, y or z, other_axes can be yz, zx or xy.
#define ALIGN_SLICES(slice_axis, other_axes) do { \
        /* Reorder slices if needed for correct transparency. */ \
        if (slice_axis > 0) slice_idx = (max_slice_count - 1) - slice_idx; \
        /* Constrain slice distance to get at most max_slice_count slices. */ \
        float slice_distance = max(slice_size_model, volume_size_model.slice_axis / (max_slice_count - 1)); \
        /* Calculate model position so that a slice will always intersect the origin. */ \
        int slice_idx_ofs = volume_origin_model.slice_axis / slice_distance; \
        pos_model.slice_axis = (slice_idx + slice_idx_ofs) * slice_distance; \
        /* Kill vertex if out of bounding box. */ \
        if (pos_model.slice_axis < volume_origin_model.slice_axis || \
            pos_model.slice_axis > volume_origin_model.slice_axis + volume_size_model.slice_axis) { \
            output.pos_clip = float4(0, 0, 0, 0); \
            return output; \
        } \
        /* Model position along non-slice axes. */ \
        pos_model.other_axes = pos_slice * volume_size_model.other_axes + volume_origin_model.other_axes; \
        /* The slice vector points toward the slice axis and has slice distance magnitude. */ \
        output.slice_vector_world = local_##slice_axis##_world * slice_distance; \
    } while (false) // Stupid but classic macro trick.

    // Slice along axis of steepest angle w.r.t. camera.
    float3 local_x_world = normalize(world_mat._m00_m10_m20);
    float3 local_y_world = normalize(world_mat._m01_m11_m21);
    float3 local_z_world = normalize(world_mat._m02_m12_m22);
    float x = dot(local_x_world, view_dir_world),
          y = dot(local_y_world, view_dir_world),
          z = dot(local_z_world, view_dir_world);
    float ax = abs(x), ay = abs(y), az = abs(z);
    if (ax > ay && ax > az) {
        ALIGN_SLICES(x, yz);
    } else if (ay > ax && ay > az) {
        ALIGN_SLICES(y, zx);
    } else {
        ALIGN_SLICES(z, xy);
    }
    output.pos_model = pos_model;

    // Texture coordinates are based on model space position, so that slicing axis doesn't affect volume orientation.
    output.tex_coord = (pos_model - volume_origin_model) / volume_size_model;

    output.pos_clip = mul(world_view_proj_mat, float4(output.pos_model, 1));

    return output;
}

// ======== FRAGMENT SHADER ========

#define OOR(x) ((x) < 0.0f || (x) > 1.0f)
#define MAXV(v) max(max(v.x, v.y), v.z)

float3 shadow_raymarch(float3 pos, float3 dir, float3 extinction)
{
    float shadow_step_model = MAXV(volume_size_model) / float(shadow_sample_count);
    int3 volume_size_voxels = tex3Dsize(volume_sampler, 0);
    float3 step_voxels = volume_size_voxels / float(shadow_sample_count);
    float step_voxels_max = MAXV(step_voxels);
    float lod = log(step_voxels_max) / log(2.f);

    float3 step_texcoords = dir / float(shadow_sample_count);

    float3 transmittance = float3(1, 1, 1);
    float3 sample_texcoords = (pos - volume_origin_model) / volume_size_model;
    for (int i = 0; i < shadow_sample_count; ++i) {
        if (OOR(sample_texcoords.x) || OOR(sample_texcoords.y) || OOR(sample_texcoords.z)) break;
        float density = SampleVolume(sample_texcoords, lod);
        transmittance *= exp(extinction * density * shadow_step_model / (1.0 + float(i) * shadow_step_model * shadow_gain));
        sample_texcoords += step_texcoords;
    }
    return transmittance;
}

typedef VERT_OUTPUT FRAG_INPUT;

struct FRAG_OUTPUT
{
    float4 color : Color0;
};

FRAG_OUTPUT VolumeFragmentShader(FRAG_INPUT input)
{
    FRAG_OUTPUT output;

    float3 extinction = -scattering - absorption;
    float3 albedo = light_color * scattering / (scattering + absorption);

    float3 light_dir_norm = normalize(light_dir);
    float3 shadow = shadow_raymarch(input.pos_model, -light_dir_norm, extinction);
    float3 lumi = albedo * shadow;

    float density = SampleVolume(input.tex_coord, 0);
    float slice_thickness = dot(input.slice_vector_world, input.slice_vector_world) / abs(dot(input.slice_vector_world, view_dir_world));
    float3 transmittance = exp(extinction * density * slice_thickness);

    output.color = float4(lumi, 1 - dot(transmittance, float3(1, 1, 1)/3));

    return output;
}

technique Main < int isTransparent = 1; > // TODO: annotations
{
    pass P0 // TODO: annotations
    {
        BlendEnable = true;
        BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha);
        CullFaceEnable = false;
        VertexProgram = compile gp5vp VolumeVertexShader();
        FragmentProgram = compile gp5fp VolumeFragmentShader();
    }
}
